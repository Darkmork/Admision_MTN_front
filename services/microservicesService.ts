import axios from 'axios';
import { getApiBaseUrl } from '../config/api.config';

/**
 * Servicio para conectar el frontend con la arquitectura de microservicios REAL
 * Este servicio se conecta directamente con nuestro API Gateway en funcionamiento
 */

// URLs base para arquitectura 100% microservicios - REAL API GATEWAY
const MICROSERVICES_GATEWAY_URL = getApiBaseUrl(); // Runtime detection: Vercel ‚Üí Railway, local ‚Üí localhost:8080
const GATEWAY_HEALTH_URL = `${MICROSERVICES_GATEWAY_URL}/health`;
const GATEWAY_STATUS_URL = `${MICROSERVICES_GATEWAY_URL}/gateway/status`;
const USER_SERVICE_URL = `${MICROSERVICES_GATEWAY_URL}/api/users`; // A trav√©s del API Gateway
const APPLICATION_SERVICE_URL = `${MICROSERVICES_GATEWAY_URL}/api/applications`;
const AUTH_SERVICE_URL = `${MICROSERVICES_GATEWAY_URL}/api/auth`;

export interface MicroserviceStatus {
  service: string;
  status: 'UP' | 'DOWN';
  url: string;
  message: string;
  architecture: 'microservices';
}

export interface ServiceInfo {
  service: string;
  version: string;
  architecture: string;
  description: string;
  endpoints?: string[];
}

export interface UserData {
  id: string;
  first_name: string;
  last_name: string;
  email: string;
  role: string;
  active: boolean;
  created_at: string;
}

export class MicroservicesService {
  private static instance: MicroservicesService;
  private currentMode: 'microservices' = 'microservices';

  public static getInstance(): MicroservicesService {
    if (!MicroservicesService.instance) {
      MicroservicesService.instance = new MicroservicesService();
    }
    return MicroservicesService.instance;
  }

  /**
   * Detectar disponibilidad de microservicios
   */
  async detectArchitecture(): Promise<'microservices' | 'unavailable'> {
    try {
      console.log('üîç Detectando microservicios reales disponibles...');
      
      const gatewayHealth = await this.checkGatewayHealth();
      const servicesHealth = await this.checkMicroservicesHealth();

      console.log('üìä Estado de microservicios:', {
        gateway: gatewayHealth.status === 'UP' ? '‚úÖ' : '‚ùå',
        servicios: servicesHealth.length > 0 ? '‚úÖ' : '‚ùå'
      });

      return 'microservices';
    } catch (error) {
      console.error('‚ùå Error detectando microservicios:', error);
      return 'unavailable';
    }
  }

  /**
   * Verificar salud del API Gateway REAL
   */
  async checkGatewayHealth(): Promise<MicroserviceStatus> {
    try {
      const response = await axios.get(GATEWAY_HEALTH_URL, { timeout: 5000 });
      return {
        service: 'api-gateway',
        status: 'UP',
        url: MICROSERVICES_GATEWAY_URL,
        message: response.data.status || 'Real API Gateway is running',
        architecture: 'microservices'
      };
    } catch (error) {
      throw {
        service: 'api-gateway',
        status: 'DOWN',
        url: MICROSERVICES_GATEWAY_URL,
        message: 'Real API Gateway is not available',
        architecture: 'microservices'
      };
    }
  }

  /**
   * Verificar salud de los microservicios REALES a trav√©s del Gateway
   */
  async checkMicroservicesHealth(): Promise<MicroserviceStatus[]> {
    const services = [
      { name: 'user-service', url: `${USER_SERVICE_URL}/health` },
      { name: 'application-service', url: `${APPLICATION_SERVICE_URL}/health` }
    ];

    const statuses: MicroserviceStatus[] = [];

    for (const service of services) {
      try {
        const response = await axios.get(service.url, { timeout: 5000 });
        statuses.push({
          service: service.name,
          status: 'UP',
          url: service.url,
          message: response.data.service || `${service.name} is running`,
          architecture: 'microservices'
        });
      } catch (error) {
        statuses.push({
          service: service.name,
          status: 'DOWN',
          url: service.url,
          message: `${service.name} is not available`,
          architecture: 'microservices'
        });
      }
    }

    return statuses;
  }

  /**
   * Obtener informaci√≥n de todos los servicios REALES
   */
  async getServicesInfo(): Promise<ServiceInfo[]> {
    const services: ServiceInfo[] = [];

    try {
      // Informaci√≥n del Gateway
      const gatewayResponse = await axios.get(GATEWAY_STATUS_URL, { timeout: 5000 });
      services.push({
        service: 'api-gateway',
        version: '1.0.0',
        architecture: 'microservices',
        description: 'Express API Gateway - Real implementation',
        endpoints: Object.keys(gatewayResponse.data.routes || {})
      });
    } catch (error) {
      console.warn('‚ö†Ô∏è No se pudo obtener informaci√≥n del Gateway');
    }

    // Informaci√≥n de los microservicios individuales
    services.push({
      service: 'user-service',
      version: '1.0.0',
      architecture: 'microservices',
      description: 'User Management Microservice (Node.js)',
      endpoints: ['/api/users', '/api/auth', '/api/users/health']
    });

    services.push({
      service: 'application-service',
      version: '1.0.0',
      architecture: 'microservices',
      description: 'Application Management Microservice (Node.js)',
      endpoints: ['/api/applications', '/api/applications/health']
    });

    return services;
  }

  /**
   * Obtener usuarios desde el microservicio REAL
   */
  async getUsersFromMicroservice(): Promise<UserData[]> {
    try {
      console.log('üë• Obteniendo usuarios del microservicio real...');
      const response = await axios.get(USER_SERVICE_URL);
      
      if (response.data.success) {
        console.log('‚úÖ Usuarios obtenidos del microservicio:', response.data.data);
        return response.data.data;
      } else {
        throw new Error('Invalid response format');
      }
    } catch (error) {
      console.error('‚ùå Error obteniendo usuarios del microservicio:', error);
      throw new Error('No se pudieron obtener usuarios del microservicio');
    }
  }

  /**
   * Obtener aplicaciones desde el microservicio REAL
   */
  async getApplicationsFromMicroservice(): Promise<any[]> {
    try {
      console.log('üìã Obteniendo aplicaciones del microservicio real...');
      const response = await axios.get(APPLICATION_SERVICE_URL);
      
      if (response.data.success) {
        console.log('‚úÖ Aplicaciones obtenidas del microservicio:', response.data.data);
        return response.data.data;
      } else {
        throw new Error('Invalid response format');
      }
    } catch (error) {
      console.error('‚ùå Error obteniendo aplicaciones del microservicio:', error);
      throw new Error('No se pudieron obtener aplicaciones del microservicio');
    }
  }

  /**
   * Probar conexi√≥n con microservicio REAL
   */
  async testMicroserviceConnection(data: any = {}): Promise<any> {
    try {
      console.log('üß™ Probando conexi√≥n con microservicio real...');
      
      // Test de usuarios
      const usersTest = await this.getUsersFromMicroservice();
      
      // Test de aplicaciones
      const applicationsTest = await this.getApplicationsFromMicroservice();
      
      // Test de gateway
      const gatewayTest = await axios.get(GATEWAY_STATUS_URL);
      
      const result = {
        gateway: gatewayTest.data,
        users: usersTest.slice(0, 2), // Mostrar solo 2 usuarios como ejemplo
        applications: applicationsTest.slice(0, 2), // Mostrar solo 2 aplicaciones como ejemplo
        timestamp: new Date().toISOString(),
        from: 'frontend',
        testData: 'Real microservices integration test'
      };
      
      console.log('‚úÖ Conexi√≥n con microservicios reales exitosa:', result);
      return result;
    } catch (error) {
      console.error('‚ùå Error en conexi√≥n con microservicios reales:', error);
      throw error;
    }
  }

  /**
   * Obtener estad√≠sticas del microservicio REAL
   */
  async getMicroserviceStats(): Promise<any> {
    try {
      console.log('üìä Obteniendo estad√≠sticas de microservicios reales...');
      
      const [users, applications] = await Promise.all([
        this.getUsersFromMicroservice(),
        this.getApplicationsFromMicroservice()
      ]);

      const stats = {
        totalUsers: users.length,
        totalApplications: applications.length,
        usersByRole: users.reduce((acc: any, user: UserData) => {
          acc[user.role] = (acc[user.role] || 0) + 1;
          return acc;
        }, {}),
        applicationsByStatus: applications.reduce((acc: any, app: any) => {
          acc[app.status] = (acc[app.status] || 0) + 1;
          return acc;
        }, {}),
        timestamp: new Date().toISOString(),
        source: 'real-microservices'
      };

      console.log('‚úÖ Estad√≠sticas obtenidas:', stats);
      return stats;
    } catch (error) {
      console.error('‚ùå Error obteniendo estad√≠sticas:', error);
      throw error;
    }
  }

  /**
   * Obtener dashboard completo de microservicios REALES
   */
  async getServicesDashboard(): Promise<{
    services: MicroserviceStatus[];
    architecture: string;
    recommendations: string[];
  }> {
    try {
      console.log('üìà Obteniendo dashboard de microservicios reales...');
      
      const gateway = await this.checkGatewayHealth();
      const services = await this.checkMicroservicesHealth();
      
      const allServices = [gateway, ...services];
      
      const recommendations = [
        'Sistema funcionando 100% con microservicios',
        'Monolito eliminado completamente',
        'API Gateway activo y funcionando',
        'Bases de datos segregadas por servicio',
        'Frontend integrado correctamente'
      ];

      return {
        services: allServices,
        architecture: '100% Microservicios (Real)',
        recommendations
      };
    } catch (error) {
      console.error('‚ùå Error obteniendo dashboard:', error);
      return {
        services: [],
        architecture: 'Error',
        recommendations: ['Error conectando con microservicios']
      };
    }
  }

  /**
   * Obtener modo actual (para compatibilidad con componentes existentes)
   */
  getCurrentMode(): string {
    return this.currentMode;
  }

  /**
   * Obtener URL base (para compatibilidad con componentes existentes)
   */
  getBaseUrl(): string {
    return MICROSERVICES_GATEWAY_URL;
  }
}

// Exportar instancia singleton
export const microservicesService = MicroservicesService.getInstance();